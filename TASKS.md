# TASKS OVERVIEW
## Task 1 : Google Cloud, SDK Authentication and Vertex AI
For the first task, we create our Google Cloud Platform account and a project associated with the following account and a service account for managing the permissions associated with the project on the Google cloud platform.

## Task 2 : Dev Environment Setup
For the following task, do check if you are able to access the following GCP account with your service account key from the code provided. Also create an environment inside which you can install all the requirements.Use the service account key to authenticate and authorize access to your GCP resources.Test the access by running a script or command that interacts with GCP services using the credentials provided in the service account key.Hence, Once you have set up the environment and installed the dependencies, run your application to ensure it functions correctly.

## Task 3 : Fast API Server Application to search flights:
Following FastAPI application is configured to interact with the flights.db database.We can run the FastAPI Server by using Uvicorn. Then we can access the API Documentation by opening a web browser and navigating to http://localhost:8000/docs. On the following page, we can use the interactive documentation to test the search-flights endpoint by providing the origin, destination, and departure date.

## Task 4 : Function Calling with Tools
Get_search_flights function is declared that helps in searching for flights based on provided parameters: origin, destination, and departure date.This function is invoked with the specified parameters to search and retrieve relevant flight information from a flight database. We create the JSON object for tools declaration providing all the necessary information relevant to specify what the following function does so that the model responds with the relevant information about the flights in the same way. Parameters for the following tool help in determining what the function does and what parameters the following function requires with specific details about the parameters and their datatype. Then we bind the following function to the search tool. After that we can bind the following tool with our Gemini model. Similarly, we can create other tools and bind the whole list of models with our Gemini model.

## Task 5 : Streamlit Integration
After creating the above tools, we just create the helper functions and attach them to Streamlit. Handle_response and llm_function are two helper functions in the sample.py that helps in unpacking responses by the Gemini model, and helps in displaying and sending streamlit messages.handle_response function checks for the function call with the intermediate step and if the function call exists it unpacks it and loads it into a function. Then it searches for the flight details mentioned in the function call using search_flights endpoint that was created beforehand and if the following flight exists If any of those flight exists then the following flight information is send again to the gemini model making it aware that there is valid flight information available in the database and then we return the response of the following function.The llm_function is another helper function for a Streamlit application, used to handle interactions with a Gemini model chat session. It sends a user's query to the LLM, processes the response, and updates the Streamlit chat interface accordingly. 

## Task 6 : Building Book_Flight Tool
Similar to the Search_Flight Tool, get_flights_booked tool is created in the sample.py and its parameters include flight number, seat_type, number of seats and flight id where the required parameters are just flight number, seat type and number of seats. After creating the following tool, we can bind it with the search tool and then with our Gemini model. After the function creation, we can create the function called book_flights similar to search_flights which can be used to construct a URL with flight booking criteria, send a POST request to this URL with the provided parameters, and return the JSON response from the server. This function abstracts the details of forming the request URL and handling the response, simplifying the process of booking a flight programmatically. Also since there is a Flight Search Criteria in the models.py, we need to create the Flight Book Criteria to handle the parameters of book_flights function which are flight id , seat type and number of seats. Now we can use the following book_flights function in the handle_response helper function which will use book_flights or search flights based on the function name it gets as a response. Here the helper function once it receives the get_flights_booked function name as response it will construct a URL, send a POST request with flight booking parameters, and process the JSON response which is the result. If successful, it sends the results as a message and returns the response content. If booking fails, it returns "Booking Failed". This ensures that the application can handle booking requests and respond appropriately based on the outcome.

## Task 7: Docker for Streamlit Application and Sqlite as Cache
Docker Setup in the following application consists of a backend Dockerfile that sets up a Python environment for running a backend server using Uvicorn, a frontend Dockerfile that sets up a Python environment for running a Streamlit frontend application and a Docker Compose file that orchestrates the deployment of both services, ensuring proper port mapping for communication between the frontend and backend.


